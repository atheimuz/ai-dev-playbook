---
title: "직접 만든 커스텀 스킬 6종 — 실전 사례집"
description: "세션 분석, 회고, granular commit, 시퀀스 다이어그램, 버그 수정 워크플로우, 스킬 동기화까지"
category: "개선"
tags: ["claude-code", "스킬", "커스텀", "자동화", "워크플로우"]
date: "2026-02-17"
---

작업하다 반복되는 패턴이 보이면 스킬로 만든다.
한번 만들어두면 매번 컨텍스트를 설명할 필요 없이, 한 줄 트리거로 동일한 워크플로우를 재현할 수 있다.
처음부터 계획해서 만든 게 아니라 하나씩 필요할 때 추가해온 것들이다.

## 1. session-analyzer — 사용 점수 자동 채점

세션 로그를 분석해서 Claude Code 사용 품질을 점수로 보여준다.

**동작 방식:**

1. 날짜 범위 질문 (오늘/어제/7일/전체/특정 날짜)
2. JSONL 세션 로그를 Python 스크립트로 분석
3. 사용된 스킬/커맨드/에이전트 동적 수집
4. 4축 스코어링 결과 생성

**4축 스코어링:**

| 축                | 배점 | 측정 내용                     |
| ----------------- | ---- | ----------------------------- |
| 의도 전달력       | 25점 | 한번에 원하는 결과가 나오는지 |
| 작업 효율성       | 30점 | 재수정 없이 처리되는 비율     |
| 도구 적합성       | 25점 | 탐색에 에이전트를 쓰는지      |
| 워크플로우 성숙도 | 20점 | 스킬/커맨드/Plan 활용도       |

스킬/커맨드 목록을 하드코딩하지 않고 동적으로 수집한다.
새 스킬을 추가해도 session-analyzer를 수정할 필요가 없다.

트리거: `/session-analyzer`, "세션 분석", "오늘 뭐했지"

## 2. retrospective — CLAUDE.md 자동 개선

세션에서 발생한 문제를 분석해서 CLAUDE.md, 에이전트, 스킬을 업데이트하는 스킬이다.

**6단계 워크플로우:**

1. 세션 컨텍스트 분석 (같은 파일 3회 이상 수정, 사용자 교정 등)
2. 7개 카테고리 분류 (pattern-mismatch, missing-rule, agent-gap 등)
3. 학습 항목 구조화 (L-001, L-002...)
4. 변경 제안서 작성
5. 사용자 승인 후 적용
6. 결과 확인

회고를 반복하면 CLAUDE.md에 프로젝트 규칙이 점진적으로 축적된다.
규칙이 정교해질수록 에이전트가 같은 실수를 반복하지 않게 되고, 사용자가 매번 교정하는 횟수가 줄어든다.
결과적으로 후속 수정 비용이 크게 감소한다.

**설계 제약:** 서브에이전트를 쓰지 않는다.
대화 컨텍스트 분석이 핵심이라 메인에서 직접 실행해야 한다.

트리거: `/retrospective`, "회고", "CLAUDE.md 업데이트"

## 3. granular-commit — hunk 단위 atomic 커밋

`git add -p`를 수동으로 하는 대신 변경사항을 논리 단위로 분석해서 커밋을 자동 분리한다.

**두 가지 경로:**

| 경로       | 조건                       | 처리                   |
| ---------- | -------------------------- | ---------------------- |
| fast-path  | 각 파일이 명확히 단일 목적 | 파일 단위로 바로 커밋  |
| patch-path | 한 파일에 여러 목적 혼재   | hunk 분석 후 분리 커밋 |

커밋 메시지는 변경 내용에서 자동 생성한다.
형식은 "feat:", "fix:", "refactor:", "test:" 접두사를 붙인다.

커밋을 상세하게 나누면 좋은 점이 많다.
`git bisect`으로 버그 원인을 빠르게 찾을 수 있고, PR 리뷰어가 변경 의도를 커밋 단위로 파악할 수 있다.
문제가 생겼을 때 해당 커밋만 `revert`하면 되니 롤백 범위가 최소화된다.
커밋 로그 자체가 변경 이력 문서 역할을 하기 때문에 나중에 "왜 이렇게 바꿨지?"를 추적하기도 쉽다.

트리거: `/granular-commit`, "커밋 나눠줘", "atomic commit"

## 4. sequence-diagram — 코드 흐름 시각화

특정 함수/기능의 코드 흐름을 분석해서 Mermaid 시퀀스 다이어그램으로 만든다.

**동작 방식:**

1. 진입점(함수명, 파일명, 기능명)을 받아서 코드 탐색
2. 호출 체인 추적
3. Mermaid 다이어그램 생성
4. PNG/SVG로 렌더링

복잡한 호출 체인을 시각적으로 한눈에 파악할 수 있어서 디버깅 시 원인 추적이 빨라진다.
생성된 다이어그램은 코드 리뷰나 신규 멤버 온보딩 시 공유 자료로도 활용할 수 있고, 아키텍처 문서로서의 역할도 한다.

트리거: `/sequence-diagram`, "시퀀스 다이어그램", "코드 흐름 분석"

## 5. bug-fix-workflow — 심각도별 파이프라인 분기

버그를 받으면 심각도를 판단해서 적합한 파이프라인으로 분기한다.

**심각도 분류:**

| 레벨          | 기준           | 파이프라인                  |
| ------------- | -------------- | --------------------------- |
| P0 (Critical) | 서비스 불가    | 즉시 분석 → 핫픽스 → 배포   |
| P1 (High)     | 주요 기능 장애 | 분석 → 테스트 → 수정 → 검증 |
| P2 (Medium)   | 부분 장애      | 재현 → 수정 → 리뷰          |
| P3 (Low)      | 경미한 이슈    | 수정                        |

심각도별로 파이프라인을 분기하면 대응 시간을 최적화할 수 있다.
P0은 분석 단계를 최소화해서 빠르게 복구하고, P2-P3는 충분한 검증을 거쳐 품질을 확보한다.
모든 버그에 동일한 프로세스를 적용하는 것보다 리소스 효율이 높고, 심각도에 맞는 일관된 품질 기준을 유지할 수 있다.

트리거: `/bug-fix`, "버그 수정", "오류 해결"

## 돌아보며

스킬을 너무 많이 만들면 트리거가 헷갈리고 관리가 힘들어진다.
"자주 쓰는 것만" 스킬로 만드는 게 맞는 것 같다.
반복되지 않는 작업은 그냥 매번 프롬프트로 요청하는 게 낫다.
