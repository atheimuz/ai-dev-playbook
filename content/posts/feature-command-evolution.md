---
title: "/feature 커맨드 개선기 — 5번의 리팩토링으로 배운 것들"
description: "4단계 병렬 실행에서 9단계 순차 파이프라인까지, /feature 커맨드의 설계 결정과 실패 기록"
category: "개선"
tags: ["claude-code", "커맨드", "워크플로우", "에이전트", "파이프라인"]
date: "2026-02-17"
---

`/feature` 커맨드를 만들어서 사용하면서 개선점이 보일때마다 계속 업데이트를 하고있다.
이 글은 각 버전에서 뭘 바꿨고, 왜 바꿨는지에 대한 내용을 기록한 것이다.

## v1: 처음 만든 날 — 4단계로 구성된 기능 구현

```
Phase 1: 기획 (product-spec-writer) → plan.md
Phase 2: [사용자 확인]
Phase 3: 병렬 실행
  ├ Task 1: ui-designer → design.md
  └ Task 2: playwright-e2e-tester  → test-scenarios.md
Phase 4: 구현 (TDD)
```

기획 명세서만 사용자가 확인하면 1) 디자인 명세서 작성과 2) 테스트 시나리오 작성 후 테스트 코드 작성이 병렬로 실행되는 방식이었다.
사용자의 컨펌 단계를 줄이고 작업을 에이전트에게 위임하는 비율이 높은 방식이었다.
이 방식의 문제점은 기존 코드의 패턴을 분석하는 단계 없이 바로 구현에 들어가기 때문에 자기 방식대로 코드를 짜는 일이 잦다는 것이다.

## v2: code-analyst 투입 — 설계에 대해 고민하는 에이전트 추가

기존 코드를 모르고 구현하는 문제를 해결하기 위해 code-analyst 에이전트를 만들었다.

```
Phase 1:   기획 → plan.md
Phase 1.5: API 명세서 확인 ← 신규
Phase 2:   [사용자 확인]
Phase 3:   병렬 실행 (2→3 Task)
  ├ Task 1: ui-designer → design.md
  ├ Task 2: playwright-e2e-tester  → test-scenarios.md
  └ Task 3: code-analyst → implementation-guide.md ← 신규
Phase 4:   구현 (implementation-guide.md 필수 참조)
```

**바뀐 것**

- code-analyst 에이전트로 기존 코드를 탐색해서 implementation-guide.md를 만들게했다.

- 구현 단계에서는 이 가이드를 "먼저 읽고 추가 탐색 없이 따른다"는 규칙을 넣었다.
- 기존 패턴과 다르게 구현 단계에서 발생하는 문제가 줄었다.
- API 명세 워크플로우도 추가했다.
- "목업 데이터로 진행" 또는 "API 명세서 제공" 중 선택하게 했다.
- 목업을 선택하면 tests/mocks/{feature}.mock.ts에 목업을 만들고 `page.route()`로 인터셉트했다.

## v3: TL;DR 의무화 — 방대한 기획 명세서

기획 문서가 너무 길면 사용자가 검토하기 어렵다.
"확인" 버튼을 누르긴 하는데, 실제로는 대충 훑고 넘어가게 되었다.
컨펌이 형식적으로 변하면 컨펌의 의미가 없다.

**해결책: 모든 산출물에 TL;DR 섹션을 의무화했다.**

| 산출물                  | TL;DR에 포함되는 내용                          |
| ----------------------- | ---------------------------------------------- |
| plan.md                 | 핵심 기능 요약 + 결정사항 테이블 + 영향 범위   |
| design.md               | 화면 구성 요약 + 컴포넌트 목록 + 상태/인터랙션 |
| test-scenarios.md       | 테스트 범위 + 시나리오 목록 + 목업 구조        |
| implementation-guide.md | 구현 방향 + 파일 목록 + 핵심 의존성            |

사용자 확인 단계에서 전체 문서 대신 **TL;DR만 먼저 보여주고**, "상세 내용 보기" 옵션을 제공했다.
30초 안에 판단할 수 있는 포맷으로 만든 게 핵심이었다.

## v4: 대규모 재구성 — 기획 단계를 오래 가져가기

새로 시작하는 프로젝트에서 `/feature`를 실제로 돌렸더니 문제가 발생했다.

**발견된 문제**

- plan.md가 **1,260줄** 나왔다 (기획+디자인+기술스펙이 전부 섞여 있었다)
- v3에서 넣은 TL;DR이 누락되는 경우가 있었다
- 스코프 통제가 안 됐다 (없어도 되는 기능까지 기획서에 포함)
- 병렬 실행한 디자인과 구현 가이드가 서로 안 맞는 경우 발생

이 문제들을 분석해서 구조를 완전히 뒤집었다.

```
Step 1: 기획 (product-spec-writer) → plan.md
Step 2: [사용자 확인] ← 기획
Step 3: 설계 (code-analyst) → implementation-guide.md
Step 4: [사용자 확인] ← 설계
Step 5: 테스트 코드 작성 (playwright-e2e-tester)
Step 6: 구현 (TDD)
Step 7: 테스트 정리 (test-consolidator)
```

**핵심 변경 5가지**

**1. Phase → Step으로 명명 변경**
Phase는 병렬 실행 가능성을 암시한다.
Step은 순차적 의존관계를 명시한다.
실제로 각 단계가 이전 단계 결과를 참조해야하니 Step으로 변경했다.

**2. 병렬 실행 폐지**
v1~v3에서는 디자인, 테스트, 코드분석을 동시에 돌렸다.
문제는 이들이 독립적이지 않다는 거였다.
디자인 없이 구현 가이드를 만들면 UI 구현이 빈약해지고, 테스트가 디자인을 모르면 실제 화면과 안 맞는다.

**3. ui-designer 삭제**
디자인을 plan.md와 implementation-guide.md에 흡수시켰다.
(이건 나중에 실수였다는 걸 알게 된다.)

**4. plan.md 경계 규칙 신설**

| 포함                      | 제외          |
| ------------------------- | ------------- |
| 배경, 사용자 스토리       | TS 인터페이스 |
| Given-When-Then 수용 기준 | API 상세      |
| P0/P1/P2 스코프           | 컴포넌트 트리 |
| 디자인 방향성             | 디자인 토큰   |

**5. 컨펌 1회 → 2회**
기획 확인과 설계 확인을 분리했다.
기획이 잘못된 채로 설계까지 가면 둘 다 되돌려야 하기 때문이다.
test-consolidator도 추가해 테스트를 세분화했다.
red(삭제) / yellow(병합) / green(유지) 기준으로 정리하는 단계가 필요했다.

## v5: 디자인 복원 — 디자이너의 역할을 다시 추가했다.

plan.md에 디자인 방향성만 넣으면 될거라 생각해 ui-designer를 삭제했다.

**틀렸다.**

디자인 명세 없이 구현하면 Claude가 "동작하는 최소한"으로 빠진다.
레이아웃이 대충 나오고, 인터랙션이 빠지고, 반응형이 어설프다.
plan.md에 "카드형 레이아웃"이라고 써도 구체적인 spacing, breakpoint, 상태별 UI가 없으면 소용없었다.
하루 만에 디자인 단계를 독립적으로 복원하고 이번에는 ux-researcher까지 추가했다.

```
Step 1: 기획 → plan.md
Step 2: [사용자 확인] ← 기획
Step 3: 디자인 ← 복원 + 강화
  3a: 디자인 레퍼런스 수집 (URL/이미지/텍스트)
  3b: UX 분석 (ux-researcher) → ux-analysis.md
  3c: UI 디자인 (ui-designer) → design.md
Step 4: [사용자 확인] ← 디자인
Step 5: 설계 (code-analyst) → implementation-guide.md
Step 6: [사용자 확인] ← 설계
Step 7: 테스트 코드 작성
Step 8: 구현 (TDD)
Step 9: 테스트 정리
```

**v4 대비 변경점**

| 항목        | v4              | v5                                 |
| ----------- | --------------- | ---------------------------------- |
| 단계 수     | 7 Step          | 9 Step                             |
| 에이전트    | 3개             | 4개 (+ux-researcher, +ui-designer) |
| 컨펌        | 2회             | 3회 (+디자인)                      |
| 디자인      | plan.md에 흡수  | 독립 단계                          |
| 산출물 체인 | plan→impl-guide | plan→ux-analysis→design→impl-guide |

**ux-researcher는 새로 도입한 에이전트다.**

Nielsen 10 휴리스틱 기반으로 기획서를 분석하고, WebFetch로 레퍼런스 URL을 가져와서 분석한다.
이 분석 결과가 ui-designer의 입력이 된다.

**디자인 레퍼런스 수집도 추가했다.**

"이런 느낌으로 만들어줘"라고 말만 하는 것보다, 실제 URL이나 스크린샷을 주면 결과가 확연히 다르다.
AskUserQuestion으로 레퍼런스를 먼저 수집한 뒤 디자인에 반영한다.

## 5번의 변경에서 발견한 패턴

### 1. 디자인은 별도 단계가 필요하다

v1: 있음 → v4: 삭제 → v5: 복원
한 번 없애보고 나서야 확실히 알았다.
기획서에 "디자인 방향성"을 적는 것과 구체적인 디자인 명세를 만드는 건 완전히 다른 일이다.

### 2. 병렬이 항상 좋은 건 아니다

v1~v3에서 디자인, 테스트, 코드분석을 병렬로 돌렸다.
빠르긴 했는데 결과물이 서로 안 맞았다.
각 단계가 이전 결과를 참조해야 한다면 순차가 맞다.
속도보다 정합성이 중요한 파이프라인에서는 병렬을 쓰면 안 된다.

### 3. 문서 스코프를 통제해야 한다

plan.md 1,260줄은 사고였다.
500줄 제한, P0/P1/P2 우선순위, "포함/제외" 경계 규칙을 넣고 나서야 통제가 됐다.
에이전트에게 "간결하게"라고 말하는 건 효과가 없다.
구체적인 제한을 규칙으로 넣어야 한다.

### 4. 실사용 피드백이 최고의 개선 동력이다

v1~v3은 "이러면 좋겠다"는 추측으로 만들었다.
v4의 대규모 변경은 새 프로젝트에서 실제로 돌린 경험에서 나왔다.
실제로 써보기 전에는 모르는 문제가 있다.

### 5. 플랜에 시간을 더 쏟아야 한다

설계가 불완전한 채로 구현에 들어가면 재수정이 발생하고, 재수정은 토큰 낭비다.
v1~v3에서 컨펌이 1회뿐이었을 때는 기획만 대충 확인하고 바로 구현으로 넘어갔다.
v4에서 2회, v5에서 3회로 늘린 건 결국 구현 전 설계를 더 꼼꼼하게 검증하겠다는 결정이었다.

목표는 총 구현 시간의 50% 이상을 플랜 단계에 쓰는 것이다.
기획, UX 분석, 디자인, 설계까지 — 구현에 들어가기 전에 충분히 시간을 써야 한다.
구현은 설계대로 옮기는 작업이 되어야지, 설계를 하면서 구현하는 작업이 되면 안 된다.

## 최종 구조의 입출력 체인

```
사용자 요청
  ↓
Step 1: product-spec-writer
  ↓ plan.md
Step 2: [확인]
  ↓
Step 3a: 레퍼런스 수집
Step 3b: ux-researcher
  ↓ ux-analysis.md
Step 3c: ui-designer
  ↓ design.md
Step 4: [확인]
  ↓
Step 5: code-analyst
  ↓ implementation-guide.md
Step 6: [확인]
  ↓
Step 7: playwright-e2e-tester
  ↓ test-scenarios.md + *.spec.ts
Step 8: TDD 구현
  ↓
Step 9: test-consolidator
  ↓ 정리된 테스트
```

각 에이전트는 이전 단계의 산출물만 참조한다.
plan.md → ux-analysis.md → design.md → implementation-guide.md 순서로 체인이 연결된다.

어느 단계에서 수정해도 그 뒤만 영향받는다.

## 돌아보며

처음부터 완벽한 워크플로우는 없다.
v1을 만들 때 v5의 구조를 상상할 수 없었다.
결국 실제로 사용하면서 문제를 발견하고, 그때마다 고쳐나가는 수밖에 없다.
계속 수정을 거듭하면서 나에게 제일 잘 맞는 워크플로우를 만들면 된다.
물론 앞으로도 고칠 일이 또 생길 거다.
그때도 이번처럼 실사용에서 문제를 발견하고 고치면 된다.

한 가지 더 고민하고 있는 건, **사용 목적에 따라 커맨드를 분리**하는 것이다.
지금의 `/feature`는 하나의 커맨드가 모든 상황을 커버하려 한다.
하지만 새 프로젝트를 처음 만드는 것, 기존 프로젝트를 리뉴얼하는 것, 이미 있는 프로젝트에 기능을 추가하는 것은 각각 필요한 단계와 깊이가 다르다.

이건 다음 개선에서 다뤄볼 주제다.
