---
title: "서브에이전트 설계 패턴"
description: "모델 배분 전략, 병렬/순차 실행, test-consolidator 활용"
category: "팁"
tags: ["claude-code", "서브에이전트", "병렬처리", "모델배분", "패턴"]
date: "2026-02-17"
---

서브에이전트를 쓰기 시작했을 때 모든 작업에 Opus를 쓰거나 에이전트 명시를 하지않았다.
하지만 토큰 비용이 예상보다 많이 나왔고, 단순한 작업에 Opus를 쓰는 게 낭비라는 걸 알게 됐다.
모델 배분, 실행 방식, 테스트 정리를 순서대로 정리한다.

## 모델 배분 전략

모든 에이전트에 같은 모델을 쓸 필요가 없다.
에이전트에 모델을 명시하지 않으면 현재 설정된 모델을 그대로 상속받는다.
Opus로 작업 중이면 서브에이전트도 전부 Opus로 실행되어 비용이 빠르게 늘어난다.

| 모델       | 사용                    | 특징                 |
| ---------- | ----------------------- | -------------------- |
| **Opus**   | 전략, 기획, 복잡한 판단 | 가장 똑똑, 가장 비쌈 |
| **Sonnet** | 구현, 코드 작성         | 균형 (기본값)        |
| **Haiku**  | 검증, 단순 분류, 포매팅 | 빠름, 저렴           |

실제 배분:

```
product-spec-writer  → Opus    (기획 방향 판단)
ux-researcher        → Opus    (사용성 분석)
code-analyst         → Sonnet  (코드 탐색 및 분석)
bug-fixer            → Sonnet  (구현)
verification-agent   → Haiku   (테스트 실행 확인)
test-consolidator    → Haiku   (분류 및 정리)
```

- Opus는 기획이나 전략 판단처럼 창의적 사고와 깊은 추론이 필요한 작업에서 빛난다.
- Sonnet은 코드 작성이나 분석처럼 정확성과 속도의 균형이 필요한 작업에 가장 적합해서, 대부분의 에이전트에 기본값으로 쓴다.
- Haiku는 분류, 포매팅, 검증처럼 규칙이 명확한 작업에서 빠르고 정확하게 동작한다.

**비싼 모델이 항상 좋은 결과를 내는 건 아니다. 작업 특성에 맞는 모델을 골라 쓰면 어떤 모델이든 최선의 선택이 된다.**

## 병렬 vs 순차 실행

언제 병렬로 실행하고, 언제 순차로 실행하는지가 중요하다.

### 병렬 실행 — 독립적인 작업

```javascript
// 단일 메시지에 Task tool 여러 개 = 병렬 실행
Task("architecture-reviewer", ...)
Task("security-reviewer", ...)
Task("performance-reviewer", ...)
// 세 개가 동시에 실행됨
```

코드 리뷰의 6개 에이전트는 전부 독립적이다.
병렬로 실행하면 6개 리뷰가 동시에 완료된다.
순차로 실행하면 6배 더 걸린다.

### 순차 체인 — 앞 결과가 뒤의 입력이 되는 작업

```
bug-analyzer → 원인 파악
     ↓
regression-tester → 재현 테스트 작성
     ↓
bug-fixer → 수정
     ↓
verification-agent → 검증
```

버그 수정 4단계는 순서가 중요하다.
원인 파악 없이 수정할 수 없고, 수정 없이 검증할 수 없다.

### 혼합 실행

```
code-analyst (병렬)     ux-researcher (병렬)
     ↓                        ↓
implementation-guide    ux-analysis
         ↓
     ui-designer (순차 — 위 두 결과 필요)
         ↓
     코드 구현 (순차)
```

독립적인 탐색 단계는 병렬로 실행하고, 그 결과를 합치는 단계는 순차로 실행한다.

## test-consolidator 활용

TDD 과정에서 테스트가 세분화되는 건 자연스럽다.
빠른 피드백을 위해 작은 테스트를 많이 만들게 된다.

test-consolidator가 이걸 정리한다.

**3단계 분류:**

| 분류   | 기준                     | 처리 |
| ------ | ------------------------ | ---- |
| red    | render-only, 존재 확인만 | 삭제 |
| yellow | 단일 체크, 유사 테스트   | 병합 |
| green  | Given-When-Then 시나리오 | 유지 |

테스트가 50개에서 18개로 줄어드는 경우도 있었다.
삭제된 테스트가 의미 없었던 게 아니라 TDD 과정에서 임시로 필요했던 것들이었다.
시나리오 기반 테스트는 전부 남겨서 회귀 방지에 쓴다.

## 돌아보며

모델 배분은 비용 관점에서도 중요하지만, 맞는 작업에 맞는 모델을 써야 결과 품질도 좋다.
Haiku로 복잡한 판단을 시키면 오히려 결과가 나빠진다.
